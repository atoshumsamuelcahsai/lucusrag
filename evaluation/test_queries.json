[
  {
    "query": "What is the CodeElement class and what does it represent?",
    "difficulty": "easy",
    "category": "data_model",
    "relevant_elements": [
      "rag.schemas.code_element.CodeElement"
    ]
  },
  {
    "query": "What is the GraphDBManager class used for?",
    "difficulty": "easy",
    "category": "database",
    "relevant_elements": [
      "rag.db.graph_db.GraphDBManager"
    ]
  },
  {
    "query": "How do I get an LLM instance in the system?",
    "difficulty": "easy",
    "category": "provider_usage",
    "relevant_elements": [
      "rag.providers.llms.get_llm"
    ]
  },
  {
    "query": "What embedding providers are supported?",
    "difficulty": "easy",
    "category": "providers",
    "relevant_elements": [
      "rag.providers.embeddings.EmbeddingProvider",
      "rag.providers.embeddings.get_embeddings"
    ]
  },
  {
    "query": "What is the ProgressTracker class?",
    "difficulty": "easy",
    "category": "utility",
    "relevant_elements": [
      "rag.schemas.progress_tracker.ProgressTracker"
    ]
  },
  {
    "query": "How do I configure the Neo4j vector index?",
    "difficulty": "easy",
    "category": "configuration",
    "relevant_elements": [
      "rag.schemas.vector_config.VectorIndexConfig"
    ]
  },
  {
    "query": "What is the QueryProcessingError exception?",
    "difficulty": "easy",
    "category": "error_handling",
    "relevant_elements": [
      "rag.exceptions.__init__.QueryProcessingError"
    ]
  },
  {
    "query": "What is the PromptFactory class?",
    "difficulty": "easy",
    "category": "prompts",
    "relevant_elements": [
      "rag.prompts.factory.PromptFactory"
    ]
  },
  {
    "query": "What code parsers are available?",
    "difficulty": "easy",
    "category": "parsing",
    "relevant_elements": [
      "rag.ast.builders.ASTParser",
      "rag.ast.builders.TreeSitterParser"
    ]
  },
  {
    "query": "How do I format function parameters for display?",
    "difficulty": "easy",
    "category": "formatting",
    "relevant_elements": [
      "rag.parser.parser.format_parameters"
    ]
  },
  {
    "query": "How are embeddings generated from different providers?",
    "difficulty": "medium",
    "category": "embeddings",
    "relevant_elements": [
      "rag.providers.embeddings.get_embeddings",
      "rag.providers.embeddings._make_openai",
      "rag.providers.embeddings._make_voyage",
      "rag.providers.embeddings._make_voyage_lite"
    ]
  },
  {
    "query": "How does query processing work from input to response?",
    "difficulty": "medium",
    "category": "query_pipeline",
    "relevant_elements": [
      "rag.query_processor.process_query",
      "rag.query_processor.get_orchestrator",
      "rag.query_processor.validate_query_text",
      "rag.indexer.orchestrator.CodeGraphIndexer"
    ]
  },
  {
    "query": "How do I configure vector indexing with Neo4j?",
    "difficulty": "medium",
    "category": "vector_config",
    "relevant_elements": [
      "rag.schemas.vector_config.VectorIndexConfig",
      "rag.schemas.vector_config.Neo4jConfig",
      "rag.schemas.vector_config.get_vector_index_config"
    ]
  },
  {
    "query": "How are code elements parsed into structured data?",
    "difficulty": "medium",
    "category": "parsing_flow",
    "relevant_elements": [
      "rag.parser.parser.process_code_element",
      "rag.parser.parser.create_text_representation",
      "rag.parser.parser.format_parameters"
    ]
  },
  {
    "query": "How does AST building work for Python files?",
    "difficulty": "medium",
    "category": "ast_building",
    "relevant_elements": [
      "rag.ast.ast_builder.build_tree_python_files",
      "rag.ast.ast_builder.analyze_and_store_python_files",
      "rag.ast.ast_builder._parse_python_file",
      "rag.ast.ast_builder.get_parser"
    ]
  },
  {
    "query": "How are different LLM providers managed and instantiated?",
    "difficulty": "medium",
    "category": "llm_providers",
    "relevant_elements": [
      "rag.providers.llms.LLMProvider",
      "rag.providers.llms.get_llm",
      "rag.providers.llms.get_anthropic_llm",
      "rag.providers.llms.get_openai_llm"
    ]
  },
  {
    "query": "How is progress tracked during file processing?",
    "difficulty": "medium",
    "category": "progress_tracking",
    "relevant_elements": [
      "rag.schemas.progress_tracker.ProgressTracker",
      "rag.schemas.processed_files_tracker.ProgressState"
    ]
  },
  {
    "query": "How does the CodeGraphIndexer orchestrate the indexing process?",
    "difficulty": "medium",
    "category": "orchestration",
    "relevant_elements": [
      "rag.indexer.orchestrator.CodeGraphIndexer",
      "rag.indexer.orchestrator.BuildResult",
      "rag.indexer.orchestrator.Mode"
    ]
  },
  {
    "query": "How are documents converted to LlamaIndex nodes?",
    "difficulty": "medium",
    "category": "document_processing",
    "relevant_elements": [
      "rag.parser.parser.to_node",
      "rag.parser.parser.parse_documents_to_nodes",
      "rag.parser.parser.create_text_representation"
    ]
  },
  {
    "query": "How are code files loaded and processed into the database?",
    "difficulty": "medium",
    "category": "data_ingestion",
    "relevant_elements": [
      "rag.ingestion.data_loader.process_code_files",
      "rag.ingestion.data_loader._process_ast_files",
      "rag.ingestion.data_loader._build_code_db_graph",
      "rag.ingestion.data_loader._check_db_populated"
    ]
  },
  {
    "query": "How does the complete AST processing pipeline work from Python files to stored elements?",
    "difficulty": "hard",
    "category": "ast_pipeline",
    "relevant_elements": [
      "rag.ast.ast_builder.analyze_and_store_python_files",
      "rag.ast.ast_builder.build_tree_python_files",
      "rag.ast.ast_builder._parse_python_file",
      "rag.ast.ast_builder._process_elements_in_file",
      "rag.ast.ast_builder._process_single_element",
      "rag.ast.ast_builder._save_element_to_file",
      "rag.ast.builders.TreeSitterParser"
    ]
  },
  {
    "query": "What is the complete flow from code files to searchable vector index?",
    "difficulty": "hard",
    "category": "end_to_end_indexing",
    "relevant_elements": [
      "rag.indexer.orchestrator.CodeGraphIndexer",
      "rag.ingestion.data_loader.process_code_files",
      "rag.ingestion.data_loader._build_code_db_graph",
      "rag.ingestion.embedding_loader.populate_embeddings",
      "rag.indexer.vector_indexer.create_vector_index_from_existing_nodes",
      "rag.indexer.vector_indexer.graph_configure_settings",
      "rag.db.graph_db.GraphDBManager"
    ]
  },
  {
    "query": "How does query execution work from API endpoint to LLM response?",
    "difficulty": "hard",
    "category": "query_execution_flow",
    "relevant_elements": [
      "rag.query_processor.process_query",
      "rag.query_processor.validate_query_text",
      "rag.query_processor.get_orchestrator",
      "rag.query_processor.initialize_query_engine",
      "rag.indexer.orchestrator.CodeGraphIndexer",
      "rag.engine.engine.make_query_engine"
    ]
  },
  {
    "query": "How are embeddings generated, stored, and indexed in Neo4j?",
    "difficulty": "hard",
    "category": "embedding_pipeline",
    "relevant_elements": [
      "rag.ingestion.embedding_loader.populate_embeddings",
      "rag.providers.embeddings.get_embeddings",
      "rag.providers.embeddings._make_openai",
      "rag.db.graph_db.GraphDBManager",
      "rag.indexer.vector_indexer.create_vector_index_from_existing_nodes"
    ]
  },
  {
    "query": "How is the graph database schema created and managed?",
    "difficulty": "hard",
    "category": "schema_management",
    "relevant_elements": [
      "rag.db.graph_db.GraphDBManager",
      "rag.ingestion.data_loader._create_schema",
      "rag.schemas.vector_config.VectorIndexConfig",
      "rag.schemas.vector_config.Neo4jConfig"
    ]
  },
  {
    "query": "How does retry logic and rate limiting work for API calls?",
    "difficulty": "hard",
    "category": "resilience",
    "relevant_elements": [
      "rag.schemas.code_element.CodeElement",
      "rag.schemas.rate_limiter.RateLimit",
      "rag.ast.ast_builder._generate_explanation_with_rate_limit"
    ]
  },
  {
    "query": "What is the complete code element lifecycle from parsing to embedding?",
    "difficulty": "hard",
    "category": "element_lifecycle",
    "relevant_elements": [
      "rag.ast.builders.TreeSitterParser",
      "rag.schemas.code_element.CodeElement",
      "rag.parser.parser.process_code_element",
      "rag.parser.parser.to_node",
      "rag.ingestion.data_loader._build_code_db_graph",
      "rag.ingestion.embedding_loader.populate_embeddings"
    ]
  },
  {
    "query": "How is configuration managed across LLMs, embeddings, and vector stores?",
    "difficulty": "hard",
    "category": "configuration_system",
    "relevant_elements": [
      "rag.schemas.vector_config.VectorIndexConfig",
      "rag.schemas.vector_config.Neo4jConfig",
      "rag.indexer.vector_indexer.graph_configure_settings",
      "rag.providers.llms.get_llm",
      "rag.providers.embeddings.get_embeddings"
    ]
  },
  {
    "query": "How does error handling work throughout the RAG pipeline?",
    "difficulty": "hard",
    "category": "error_handling_system",
    "relevant_elements": [
      "rag.exceptions.__init__.AppError",
      "rag.exceptions.__init__.QueryProcessingError",
      "rag.query_processor.process_query",
      "rag.schemas.code_element.CodeElement",
      "rag.ast.ast_builder._process_single_element"
    ]
  },
  {
    "query": "How do the provider registry and factory patterns work for embeddings and LLMs?",
    "difficulty": "hard",
    "category": "provider_patterns",
    "relevant_elements": [
      "rag.providers.embeddings.register_embedding",
      "rag.providers.embeddings.get_embeddings",
      "rag.providers.embeddings.EmbeddingProvider",
      "rag.providers.llms.get_llm",
      "rag.providers.llms.LLMProvider"
    ]
  }
]
