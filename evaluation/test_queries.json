[
  {
    "query": "What is the VoyageEmbedding class used for?",
    "difficulty": "easy",
    "category": "simple_lookup",
    "relevant_files": [
      "rag/providers/embeddings.py"
    ],
    "relevant_elements": [
      "rag.providers.embeddings._make_voyage_lite",
      "rag.providers.embeddings._make_voyage_large",
      "rag.providers.embeddings.get_embeddings"
    ]
  },
  {
    "query": "How do I configure Neo4j connection?",
    "difficulty": "easy",
    "category": "configuration",
    "relevant_files": [
      "rag/schemas/vector_config.py"
    ],
    "relevant_elements": [
      "rag.schemas.vector_config.Neo4jConfig",
      "rag.schemas.vector_config.VectorIndexConfig"
    ]
  },
  {
    "query": "What does the health check endpoint return?",
    "difficulty": "easy",
    "category": "api_endpoint",
    "relevant_files": [
      "server.py"
    ],
    "relevant_elements": [
      "server.health_check"
    ]
  },
  {
    "query": "What is the CodeElement dataclass?",
    "difficulty": "easy",
    "category": "data_model",
    "relevant_files": [
      "rag/schemas/code_element.py"
    ],
    "relevant_elements": [
      "rag.schemas.code_element.CodeElement"
    ]
  },
  {
    "query": "How do I get an Anthropic LLM instance?",
    "difficulty": "easy",
    "category": "provider_usage",
    "relevant_files": [
      "rag/providers/llms.py"
    ],
    "relevant_elements": [
      "rag.providers.llms.get_anthropic_llm",
      "rag.providers.llms.get_llm"
    ]
  },
  {
    "query": "What LLM providers are supported?",
    "difficulty": "easy",
    "category": "enumeration",
    "relevant_files": [
      "rag/providers/llms.py"
    ],
    "relevant_elements": [
      "rag.providers.llms.LLMProvider",
      "rag.providers.llms.get_llm"
    ]
  },
  {
    "query": "What is the GraphDBManager class?",
    "difficulty": "easy",
    "category": "database",
    "relevant_files": [
      "rag/db/graph_db.py"
    ],
    "relevant_elements": [
      "rag.db.graph_db.GraphDBManager"
    ]
  },
  {
    "query": "What parsers are available for code?",
    "difficulty": "easy",
    "category": "parsing",
    "relevant_files": [
      "rag/ast/builders.py"
    ],
    "relevant_elements": [
      "rag.ast.builders.ASTParser",
      "rag.ast.builders.TreeSitterParser"
    ]
  },
  {
    "query": "What is the QueryProcessingError exception?",
    "difficulty": "easy",
    "category": "error_handling",
    "relevant_files": [
      "rag/exceptions/__init__.py"
    ],
    "relevant_elements": [
      "rag.exceptions.QueryProcessingError"
    ]
  },
  {
    "query": "How do I create a progress tracker?",
    "difficulty": "easy",
    "category": "utility",
    "relevant_files": [
      "rag/schemas/progress_tracker.py"
    ],
    "relevant_elements": [
      "rag.schemas.progress_tracker.ProgressTracker"
    ]
  },
  {
    "query": "How are code elements converted to graph nodes?",
    "difficulty": "medium",
    "category": "transformation",
    "relevant_files": [
      "rag/parser/parser.py",
      "rag/schemas/code_element.py"
    ],
    "relevant_elements": [
      "rag.parser.parser.to_node",
      "rag.parser.parser.create_text_representation",
      "rag.schemas.code_element.CodeElement.to_dict"
    ]
  },
  {
    "query": "How does the query processing pipeline work?",
    "difficulty": "medium",
    "category": "pipeline_flow",
    "relevant_files": [
      "rag/query_processor.py",
      "rag/indexer/orchestrator.py",
      "rag/engine/engine.py"
    ],
    "relevant_elements": [
      "rag.query_processor.process_query",
      "rag.query_processor.get_orchestrator",
      "rag.indexer.orchestrator.CodeGraphIndexer.aquery",
      "rag.engine.engine.make_query_engine"
    ]
  },
  {
    "query": "How are embeddings generated and stored in Neo4j?",
    "difficulty": "medium",
    "category": "embeddings_pipeline",
    "relevant_files": [
      "rag/ingestion/embedding_loader.py",
      "rag/providers/embeddings.py",
      "rag/db/graph_db.py"
    ],
    "relevant_elements": [
      "rag.ingestion.embedding_loader.populate_embeddings",
      "rag.providers.embeddings.get_embeddings",
      "rag.db.graph_db.GraphDBManager.upsert_embeddings"
    ]
  },
  {
    "query": "How does the incremental refresh detect changed files?",
    "difficulty": "medium",
    "category": "incremental_update",
    "relevant_files": [
      "rag/indexer/orchestrator.py"
    ],
    "relevant_elements": [
      "rag.indexer.orchestrator.CodeGraphIndexer.refresh",
      "rag.indexer.orchestrator.CodeGraphIndexer._diff",
      "rag.indexer.orchestrator.CodeGraphIndexer._snapshot_files",
      "rag.indexer.orchestrator.CodeGraphIndexer._sha256"
    ]
  },
  {
    "query": "How is retry logic implemented for API calls?",
    "difficulty": "medium",
    "category": "resilience",
    "relevant_files": [
      "rag/schemas/code_element.py"
    ],
    "relevant_elements": [
      "rag.schemas.code_element.CodeElement._with_retries",
      "rag.schemas.code_element.CodeElement.generate_explanation"
    ]
  },
  {
    "query": "How does concurrent AST processing work?",
    "difficulty": "medium",
    "category": "concurrency",
    "relevant_files": [
      "rag/ast/ast_builder.py"
    ],
    "relevant_elements": [
      "rag.ast.ast_builder.build_tree_python_files",
      "rag.ast.ast_builder._process_elements_in_file",
      "rag.ast.ast_builder._process_single_element",
      "rag.ast.ast_builder._generate_explanation_with_rate_limit"
    ]
  },
  {
    "query": "How are Python AST files parsed and processed?",
    "difficulty": "medium",
    "category": "parsing_pipeline",
    "relevant_files": [
      "rag/ast/ast_builder.py",
      "rag/ast/builders.py",
      "rag/parser/parser.py"
    ],
    "relevant_elements": [
      "rag.ast.ast_builder.analyze_and_store_python_files",
      "rag.ast.ast_builder.build_tree_python_files",
      "rag.ast.builders.ASTParser",
      "rag.parser.parser.parse_documents_to_nodes"
    ]
  },
  {
    "query": "How does the vector index get created from Neo4j nodes?",
    "difficulty": "medium",
    "category": "vector_indexing",
    "relevant_files": [
      "rag/indexer/vector_indexer.py",
      "rag/db/graph_db.py"
    ],
    "relevant_elements": [
      "rag.indexer.vector_indexer.create_vector_index_from_existing_nodes",
      "rag.indexer.vector_indexer.graph_configure_settings",
      "rag.db.graph_db.GraphDBManager.get_all_nodes"
    ]
  },
  {
    "query": "How are function parameters formatted for display?",
    "difficulty": "medium",
    "category": "formatting",
    "relevant_files": [
      "rag/parser/parser.py"
    ],
    "relevant_elements": [
      "ag.parser.parser.format_parameters"
    ]
  },
  {
    "query": "What happens when a query is submitted to the FastAPI endpoint?",
    "difficulty": "medium",
    "category": "request_flow",
    "relevant_files": [
      "server.py",
      "rag/query_processor.py"
    ],
    "relevant_elements": [
      "server.query_endpoint",
      "rag.query_processor.process_query",
      "rag.query_processor.validate_query_text"
    ]
  },
  {
    "query": "How does the complete indexing pipeline work from code files to searchable index?",
    "difficulty": "hard",
    "category": "end_to_end_pipeline",
    "relevant_files": [
      "rag/indexer/orchestrator.py",
      "rag/ingestion/data_loader.py",
      "rag/ingestion/embedding_loader.py",
      "rag/indexer/vector_indexer.py",
      "rag/db/graph_db.py"
    ],
    "relevant_elements": [
      "rag.indexer.orchestrator.CodeGraphIndexer.build",
      "rag.ingestion.data_loader.process_code_files",
      "rag.ingestion.data_loader._build_code_db_graph",
      "rag.ingestion.embedding_loader.populate_embeddings",
      "rag.indexer.vector_indexer.create_vector_index_from_existing_nodes",
      "rag.db.graph_db.GraphDBManager.upsert_node",
      "rag.db.graph_db.GraphDBManager.upsert_relationship"
    ]
  },
  {
    "query": "How are code dependencies tracked and stored in the graph database?",
    "difficulty": "hard",
    "category": "graph_relationships",
    "relevant_files": [
      "rag/ast/builders.py",
      "rag/ingestion/data_loader.py",
      "rag/db/graph_db.py",
      "rag/parser/parser.py"
    ],
    "relevant_elements": [
      "rag.ast.builders.ASTParser._extract_dependencies",
      "rag.ast.builders.TreeSitterParser._extract_imports",
      "rag.ingestion.data_loader._build_code_db_graph",
      "rag.db.graph_db.GraphDBManager.upsert_relationship",
      "rag.parser.parser.process_code_element"
    ]
  },
  {
    "query": "How does the system handle both cold start and incremental updates?",
    "difficulty": "hard",
    "category": "lifecycle_management",
    "relevant_files": [
      "rag/indexer/orchestrator.py",
      "rag/ingestion/data_loader.py",
      "rag/db/graph_db.py"
    ],
    "relevant_elements": [
      "rag.indexer.orchestrator.CodeGraphIndexer.build",
      "rag.indexer.orchestrator.CodeGraphIndexer.refresh",
      "rag.indexer.orchestrator.CodeGraphIndexer._diff",
      "rag.ingestion.data_loader.process_code_files",
      "rag.ingestion.data_loader._check_db_populated",
      "rag.db.graph_db.GraphDBManager.clear_database"
    ]
  },
  {
    "query": "What is the complete flow for generating AI explanations for code elements?",
    "difficulty": "hard",
    "category": "ai_explanation_pipeline",
    "relevant_files": [
      "rag/schemas/code_element.py",
      "rag/prompts/factory.py",
      "rag/providers/llms.py",
      "rag/ast/ast_builder.py"
    ],
    "relevant_elements": [
      "rag.schemas.code_element.CodeElement.generate_explanation",
      "rag.schemas.code_element.CodeElement._with_retries",
      "rag.prompts.factory.PromptFactory.render",
      "rag.prompts.factory.PromptFactory.get_instance",
      "rag.providers.llms.get_llm",
      "rag.ast.ast_builder._generate_explanation_with_rate_limit"
    ]
  },
  {
    "query": "How does the query engine combine vector retrieval with graph traversal?",
    "difficulty": "hard",
    "category": "hybrid_retrieval",
    "relevant_files": [
      "rag/engine/engine.py",
      "rag/indexer/vector_indexer.py",
      "rag/indexer/orchestrator.py"
    ],
    "relevant_elements": [
      "rag.engine.engine.make_query_engine",
      "rag.indexer.vector_indexer.create_vector_index_from_existing_nodes",
      "rag.indexer.orchestrator.CodeGraphIndexer.aquery",
      "rag.indexer.orchestrator.CodeGraphIndexer.build"
    ]
  },
  {
    "query": "How are AST files processed, stored, and tracked for incremental updates?",
    "difficulty": "hard",
    "category": "file_processing_lifecycle",
    "relevant_files": [
      "rag/ast/ast_builder.py",
      "rag/schemas/processed_files_tracker.py",
      "rag/ingestion/data_loader.py"
    ],
    "relevant_elements": [
      "rag.ast.ast_builder.analyze_and_store_python_files",
      "rag.ast.ast_builder.build_tree_python_files",
      "rag.ast.ast_builder._process_single_element",
      "rag.schemas.processed_files_tracker.ProgressState",
      "rag.schemas.processed_files_tracker.ProgressState.add_element",
      "rag.ingestion.data_loader._process_ast_files"
    ]
  },
  {
    "query": "How does error handling and recovery work throughout the RAG pipeline?",
    "difficulty": "hard",
    "category": "error_handling_system",
    "relevant_files": [
      "rag/exceptions/__init__.py",
      "rag/query_processor.py",
      "rag/schemas/code_element.py",
      "rag/ast/ast_builder.py",
      "server.py"
    ],
    "relevant_elements": [
      "rag.exceptions.QueryProcessingError",
      "rag.exceptions.AppError",
      "rag.query_processor.process_query",
      "rag.schemas.code_element.CodeElement._with_retries",
      "rag.ast.ast_builder._process_single_element",
      "server.query_endpoint"
    ]
  },
  {
    "query": "How are database schemas created and maintained across different versions?",
    "difficulty": "hard",
    "category": "schema_management",
    "relevant_files": [
      "rag/db/graph_db.py",
      "rag/ingestion/data_loader.py",
      "rag/schemas/vector_config.py"
    ],
    "relevant_elements": [
      "rag.db.graph_db.GraphDBManager.create_schema",
      "rag.db.graph_db.GraphDBManager.create_vector_index",
      "rag.ingestion.data_loader._create_schema",
      "rag.schemas.vector_config.VectorIndexConfig"
    ]
  },
  {
    "query": "What is the complete initialization sequence when the RAG system starts?",
    "difficulty": "hard",
    "category": "system_initialization",
    "relevant_files": [
      "rag/query_processor.py",
      "rag/indexer/orchestrator.py",
      "rag/indexer/vector_indexer.py",
      "rag/db/graph_db.py"
    ],
    "relevant_elements": [
      "rag.query_processor.initialize_query_engine",
      "rag.query_processor.get_orchestrator",
      "rag.indexer.orchestrator.CodeGraphIndexer.build",
      "rag.indexer.vector_indexer.graph_configure_settings",
      "rag.db.graph_db.GraphDBManager.__init__"
    ]
  },
  {
    "query": "How does the system handle concurrent API requests with rate limiting?",
    "difficulty": "hard",
    "category": "concurrency_control",
    "relevant_files": [
      "rag/ast/ast_builder.py",
      "rag/schemas/code_element.py",
      "rag/query_processor.py"
    ],
    "relevant_elements": [
      "rag.ast.ast_builder.build_tree_python_files",
      "rag.ast.ast_builder._generate_explanation_with_rate_limit",
      "rag.ast.ast_builder._process_elements_in_file",
      "rag.schemas.code_element.CodeElement._with_retries",
      "rag.query_processor.get_orchestrator"
    ]
  }
]